<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jenga Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
        }

        #next-move-btn,
        #reset-btn,
        #time-select {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            backdrop-filter: blur(5px);
            transition: background 0.3s;
        }

        #next-move-btn:hover,
        #reset-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        #time-select {
            padding: 10px;
        }

        #time-select option {
            background: rgba(0, 0, 0, 0.9);
            color: white;
        }

        #countdown-display {
            margin-left: 10px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            min-width: 60px;
            display: inline-block;
        }

        #instruction {
            margin-top: 10px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #move-counter {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>

<body>
    <div id="ui-container">
        <button id="next-move-btn">Next Move</button>
        <button id="reset-btn" style="margin-left: 10px;">Reset</button>
        <select id="time-select" style="margin-left: 10px;">
            <option value="5000">5 sec</option>
            <option value="10000" selected>10 sec</option>
            <option value="15000">15 sec</option>
        </select>
        <span id="countdown-display"></span>
        <div id="instruction">Press "Next Move" to start</div>
    </div>
    <div id="move-counter">Moves: 0</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // --- PhysicsWorld ---
        class PhysicsWorld {
            constructor() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 10;
                this.addGround();
            }

            addGround() {
                const groundShape = new CANNON.Plane();
                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
                this.world.addBody(groundBody);
            }

            update(dt) {
                this.world.step(1 / 60, dt, 3);
            }

            addBody(body) {
                this.world.addBody(body);
            }

            removeBody(body) {
                this.world.removeBody(body);
            }
        }

        // --- Renderer ---
        class Renderer {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x202020);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(8, 11, 10);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.target.set(0, 6, 0);

                this.setupLights();
                this.addGround();

                window.addEventListener('resize', () => this.onWindowResize(), false);
            }

            setupLights() {
                const ambientLight = new THREE.AmbientLight(0x606060);
                this.scene.add(ambientLight);

                // Add light to camera so it follows the view
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(0, 0, 1);
                this.camera.add(dirLight);
                this.scene.add(this.camera);
            }

            addGround() {
                const geometry = new THREE.PlaneGeometry(100, 100);
                const material = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const plane = new THREE.Mesh(geometry, material);
                plane.rotation.x = -Math.PI / 2;
                plane.receiveShadow = true;
                this.scene.add(plane);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            render() {
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            add(object) {
                this.scene.add(object);
            }

            remove(object) {
                this.scene.remove(object);
            }
        }

        // --- Block ---
        class Block {
            constructor(x, y, z, rotation, material) {
                this.width = 1;
                this.height = 0.6;
                this.depth = 3;

                // Three.js Mesh
                const geometry = new THREE.BoxGeometry(this.width, this.height, this.depth);
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(x, y, z);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

                // Add edges
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges, 
                    new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
                );
                this.mesh.add(line);

                if (rotation) {
                    this.mesh.rotation.y = rotation;
                }

                // Cannon.js Body
                const shape = new CANNON.Box(new CANNON.Vec3(this.width / 2, this.height / 2, this.depth / 2));
                this.body = new CANNON.Body({ mass: 0 }); // Static body
                this.body.addShape(shape);
                this.body.position.set(x, y, z);

                if (rotation) {
                    const q = new CANNON.Quaternion();
                    q.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotation);
                    this.body.quaternion.copy(q);
                }
            }

            update() {
                this.mesh.position.copy(this.body.position);
                this.mesh.quaternion.copy(this.body.quaternion);
            }
        }

        // --- Game ---
        class Game {
            constructor() {
                this.physicsWorld = new PhysicsWorld();
                this.renderer = new Renderer();
                this.blocks = [];
                this.layerCount = 0;
                this.moveCount = 0;
                this.isAnimating = false;
                this.moveTimeout = null;
                this.countdownInterval = null;
                this.countdownEndTime = null;

                this.woodMaterial = new THREE.MeshStandardMaterial({
                    color: 0xeebb99,
                    roughness: 0.5
                });

                this.setupUI();
            }

            setupUI() {
                this.nextMoveBtn = document.getElementById('next-move-btn');
                this.resetBtn = document.getElementById('reset-btn');
                this.instructionText = document.getElementById('instruction');
                this.moveCounterText = document.getElementById('move-counter');
                this.timeSelect = document.getElementById('time-select');
                this.countdownDisplay = document.getElementById('countdown-display');

                this.nextMoveBtn.addEventListener('click', () => {
                    if (this.isAnimating) {
                        // Skip current animation and move to next
                        this.skipToNextMove();
                    } else {
                        this.performNextMove();
                    }
                });

                this.resetBtn.addEventListener('click', () => {
                    this.reset();
                });
            }

            reset() {
                if (this.moveTimeout) clearTimeout(this.moveTimeout);
                if (this.countdownInterval) clearInterval(this.countdownInterval);
                this.countdownDisplay.textContent = '';
                this.isAnimating = false;

                // Remove all blocks
                for (const block of this.blocks) {
                    this.renderer.remove(block.mesh);
                    this.physicsWorld.removeBody(block.body);
                }
                this.blocks = [];
                this.layerCount = 0;
                this.moveCount = 0;
                this.moveCounterText.textContent = 'Moves: 0';

                this.instructionText.textContent = "Game Reset! Press Next Move.";
                this.generateTower();
            }

            start() {
                this.generateTower();
                this.loop();
            }

            generateTower() {
                const levels = 14;
                for (let i = 0; i < levels; i++) {
                    this.addLayer(i);
                }
            }

            addLayer(level) {
                const y = 0.3 + level * 0.6;
                const isEven = level % 2 === 0;

                for (let i = 0; i < 3; i++) {
                    let x, z, rotation;

                    if (isEven) {
                        x = 0;
                        z = (i - 1) * 1.05;
                        rotation = Math.PI / 2;
                    } else {
                        x = (i - 1) * 1.05;
                        z = 0;
                        rotation = 0;
                    }

                    const block = new Block(x, y, z, rotation, this.woodMaterial);
                    this.blocks.push(block);
                    this.renderer.add(block.mesh);
                    this.physicsWorld.addBody(block.body);
                }
                this.layerCount++;
            }

            getSafeBlock() {
                // Group blocks by layer
                const layers = {};
                this.blocks.forEach(block => {
                    const layerIndex = Math.round((block.mesh.position.y - 0.3) / 0.6);
                    if (!layers[layerIndex]) layers[layerIndex] = [];
                    layers[layerIndex].push(block);
                });

                const validBlocks = [];

                // Iterate through layers (exclude top 2)
                for (let i = 0; i < this.layerCount - 1; i++) {
                    const layerBlocks = layers[i];
                    if (!layerBlocks || layerBlocks.length === 0) continue;

                    // Sort blocks by position to determine Left, Center, Right
                    const isEven = i % 2 === 0;

                    // Sort based on axis
                    layerBlocks.sort((a, b) => {
                        return isEven ? a.mesh.position.z - b.mesh.position.z : a.mesh.position.x - b.mesh.position.x;
                    });

                    // Map to slots [-1, 0, 1] roughly
                    // Better slot assignment using actual positions
                    const slots = [null, null, null]; // [left, center, right]
                    
                    if (layerBlocks.length === 1) {
                        // Single block - assign to closest slot
                        const pos = isEven ? layerBlocks[0].mesh.position.z : layerBlocks[0].mesh.position.x;
                        if (Math.abs(pos + 1.05) < 0.3) slots[0] = layerBlocks[0];
                        else if (Math.abs(pos) < 0.3) slots[1] = layerBlocks[0];
                        else if (Math.abs(pos - 1.05) < 0.3) slots[2] = layerBlocks[0];
                    } else if (layerBlocks.length === 2) {
                        // Two blocks - assign based on sorted positions
                        const pos0 = isEven ? layerBlocks[0].mesh.position.z : layerBlocks[0].mesh.position.x;
                        const pos1 = isEven ? layerBlocks[1].mesh.position.z : layerBlocks[1].mesh.position.x;
                        
                        // First block (leftmost)
                        if (Math.abs(pos0 + 1.05) < 0.3) slots[0] = layerBlocks[0];
                        else if (Math.abs(pos0) < 0.3) slots[1] = layerBlocks[0];
                        
                        // Second block
                        if (Math.abs(pos1) < 0.3) slots[1] = layerBlocks[1];
                        else if (Math.abs(pos1 - 1.05) < 0.3) slots[2] = layerBlocks[1];
                    } else if (layerBlocks.length === 3) {
                        // Three blocks - assign in order
                        slots[0] = layerBlocks[0]; // left
                        slots[1] = layerBlocks[1]; // center
                        slots[2] = layerBlocks[2]; // right
                    }

                    // Apply Rules
                    const hasLeft = !!slots[0];
                    const hasCenter = !!slots[1];
                    const hasRight = !!slots[2];

                    if (hasLeft && hasCenter && hasRight) {
                        // xxx -> Any
                        // ramdonly decide if if whould allow to remove the center block or not
                        if (Math.random() < 0.5) {
                            validBlocks.push(slots[0], slots[1], slots[2]);
                        } else {
                            validBlocks.push(slots[0], slots[2]);
                        }
                    } else if (hasLeft && hasCenter && !hasRight) {
                        // xxo -> Left only
                        validBlocks.push(slots[0]);
                    } else if (!hasLeft && hasCenter && hasRight) {
                        // oxx -> Right only
                        validBlocks.push(slots[2]);
                    }
                    // xox, single blocks, etc -> None
                }

                if (validBlocks.length === 0) {
                    console.log("No valid blocks found", layers);
                    return null;
                }
                return validBlocks[Math.floor(Math.random() * validBlocks.length)];
            }

            performNextMove() {
                const performMoveTime = parseInt(this.timeSelect.value);
                this.isAnimating = true;
                this.instructionText.textContent = "Finding a safe block...";

                const selectedBlock = this.getSafeBlock();

                if (!selectedBlock) {
                    this.instructionText.textContent = "No safe moves found!";
                    this.collapseTower();
                    return;
                }

                // Highlight
                selectedBlock.mesh.material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const seconds = performMoveTime / 1000;
                this.instructionText.textContent = `Removing block in ${seconds}s...`;

                // Start countdown
                this.countdownEndTime = Date.now() + performMoveTime;
                this.updateCountdown();
                this.countdownInterval = setInterval(() => this.updateCountdown(), 100);

                this.moveTimeout = setTimeout(() => {
                    this.removeBlock(selectedBlock);
                }, performMoveTime);
            }

            updateCountdown() {
                const remaining = Math.max(0, this.countdownEndTime - Date.now());
                const seconds = (remaining / 1000).toFixed(1);
                this.countdownDisplay.textContent = `${seconds}s`;
                
                if (remaining <= 0 && this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                    this.countdownDisplay.textContent = '';
                }
            }

            skipToNextMove() {
                // Clear existing timers
                if (this.moveTimeout) {
                    clearTimeout(this.moveTimeout);
                    this.moveTimeout = null;
                }
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                this.countdownDisplay.textContent = '';
                
                // Find and remove the currently selected block (red one)
                const selectedBlock = this.blocks.find(block => 
                    block.mesh.material.color.getHex() === 0xff0000
                );
                
                if (selectedBlock) {
                    this.removeBlock(selectedBlock);
                }
                
                // Start next move
                this.performNextMove();
            }

            removeBlock(block) {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                this.countdownDisplay.textContent = '';
                
                this.instructionText.textContent = "Block removed!";

                // Remove from scene and world
                this.renderer.remove(block.mesh);
                this.physicsWorld.removeBody(block.body);

                // Remove from array
                const index = this.blocks.indexOf(block);
                if (index > -1) {
                    this.blocks.splice(index, 1);
                }

                this.moveCount++;
                this.moveCounterText.textContent = `Moves: ${this.moveCount}`;

                // Check progression
                if (this.moveCount % 3 === 0) {
                    this.addNewLayer();
                    this.instructionText.textContent = "New layer added!";
                } else {
                    this.instructionText.textContent = "Your turn! Press Next Move.";
                }

                this.isAnimating = false;
            }

            addNewLayer() {
                this.addLayer(this.layerCount);
            }

            collapseTower() {
                this.instructionText.textContent = "Tower collapsing...";
                
                // Make all blocks dynamic (affected by gravity)
                for (const block of this.blocks) {
                    // Change body type to dynamic
                    block.body.type = CANNON.Body.DYNAMIC;
                    block.body.mass = 1;
                    block.body.updateMassProperties();
                    block.body.wakeUp();
                    
                    // Add random impulse to trigger collapse
                    const impulse = new CANNON.Vec3(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 5
                    );
                    const worldPoint = new CANNON.Vec3(
                        block.body.position.x + (Math.random() - 0.5) * 0.5,
                        block.body.position.y + (Math.random() - 0.5) * 0.3,
                        block.body.position.z + (Math.random() - 0.5) * 0.5
                    );
                    block.body.applyImpulse(impulse, worldPoint);
                }

                // Show reset message after collapse
                setTimeout(() => {
                    this.instructionText.textContent = "Game Over! Press Reset to play again.";
                }, 3000);
            }

            loop() {
                requestAnimationFrame(() => this.loop());

                const dt = 1 / 60;
                this.physicsWorld.update(dt);

                for (const block of this.blocks) {
                    block.update();
                }

                this.renderer.render();
            }
        }

        // --- Main ---
        const game = new Game();
        game.start();
    </script>
</body>

</html>